#! /usr/bin/env python

import hashlib
import binascii
import sys
import re
import base64
from socket import socket
from ecdsa import SigningKey
from ecdsa import VerifyingKey
from ecdsa.numbertheory import inverse_mod

#we use the public ECDSA key to get its order
public_key_ec_pem = '''
-----BEGIN PUBLIC KEY-----
MEkwEwYHKoZIzj0CAQYIKoZIzj0DAQEDMgAEC30eTFiv0eqkq4gawnZSoHt+z/Vv
RW2s5YxOD+KGg7CukkXm3jj2YTXV8vRIvBiS
-----END PUBLIC KEY-----
'''
public_key_ec = VerifyingKey.from_pem(public_key_ec_pem.strip())
curve_order = public_key_ec.curve.order



def string_to_number(tstr):
    return int(binascii.hexlify(tstr), 16)
    
def sha1(content):
    sha1_hash = hashlib.sha1()
    sha1_hash.update(content)
    hash = sha1_hash.digest()
    return hash

def recover_key(c1,sig1,c2,sig2):
    #using the same variable names as in: 
    #http://en.wikipedia.org/wiki/Elliptic_Curve_DSA
    n = curve_order
    s1 = string_to_number(sig1[-24:])
    s2 = string_to_number(sig2[-24:])
    r = string_to_number(sig1[-48:-24])

    z1 = string_to_number(sha1(c1))
    z2 = string_to_number(sha1(c2))

    sdiff_inv = inverse_mod(((s1-s2)%n),n)
    k = ( ((z1-z2)%n) * sdiff_inv) % n
    r_inv = inverse_mod(r,n)
    da = (((((s1*k) %n) -z1) %n) * r_inv) % n
    
    recovered_private_key_ec = SigningKey.from_secret_exponent(da)
    return recovered_private_key_ec.to_pem()
    
class Client():
    def wait_for_regex(self, regex, pdata=False):
        compiled_regex = re.compile(regex)
        while True:
            data = self.sock_file.readline()
            if(pdata):
                print "->" + repr(data) + "<-"
            if(len(data)==0):
                raise Exception("Exit")
            elif (compiled_regex.match(data)):
                break;
    def send_msg(self, data):
        self.sock.sendall(data + "\n")
    def __init__(self,ip,port):
        self.sock = socket()
        self.sock.connect((ip,port))
        self.sock_file = self.sock.makefile()

if __name__ == "__main__":
    #you can get cmd1, sig1, cms2, sig2 by recording
    #benign traffic (generated by benign3.py)
    cmd1 = "power|1191|327"
    sig1 = '''
WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFh
YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF
hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYW
FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDVDOQcpfMN4sAFXAzdHKdek/kZkcITkuiX7FY+l
x+clsGPzn1F+WrOc0gxya/oDGw==
    '''.strip()
    
    cmd2 = "power|2747|3713"
    sig2 = '''
WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFh
YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF
hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYW
FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDVDOQcpfMN4sAFXAzdHKdek/kZkcITkumX7FY+n
SWLDPFKlMKSDwRMN85yGorBepg==
    '''.strip()
    
    key = recover_key(cmd1,base64.b64decode(sig1),cmd2,base64.b64decode(sig2))
    print key
    
    #use the recovered key to generate a L3 signature and execute a command
    private_key_ec = SigningKey.from_pem(key)
    command = "power|33|77"
    #the following will work as well (of course, if <flag_id> must exist)
    #command = "read_encrypted2|<flag_id>|0"
    hash = sha1(command)
    cert_key = private_key_ec.sign_digest(hash)
    cert = "X"*(256-len(cert_key)) + cert_key
    
    c = Client(sys.argv[1],int(sys.argv[2]))
    c.wait_for_regex("^what do you want")
    c.send_msg(command)
    c.wait_for_regex("^give me the certificate")
    c.send_msg(base64.b64encode(cert))
    c.wait_for_regex("^Bye")
    
    
    